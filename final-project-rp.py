# -*- coding: utf-8 -*-
"""final project rp.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KiIm0ocwASBeYMrdre-HRye_NPfxo0dn
"""

#MODEL DEVELOPED

import streamlit as st
import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestRegressor  # Ensure this is included
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, mean_squared_error

@st.cache_data
def load_and_preprocess_data(file_paths):
    dataframes = [pd.read_csv(file) for file in file_paths]

    # Rename columns for compatibility
    for i, df in enumerate(dataframes):
        if 'Restaurant Name' in df.columns:
            df.rename(columns={'Restaurant Name': 'name', 'Address': 'address', 'City': 'city',
                               'Locality': 'locality', 'Cuisines': 'cuisines', 'Average Cost for Two': 'average_cost_for_two',
                               'Aggregate Rating': 'aggregate_rating', 'Price Range': 'price_range'}, inplace=True)

    # Merge all dataframes
    merged_df = pd.concat(dataframes, axis=0, ignore_index=True)

    # Explicitly create a copy of the relevant slice
    key_columns = ['name', 'address', 'city', 'locality', 'cuisines', 'average_cost_for_two',
                   'aggregate_rating', 'votes', 'price_range', 'latitude', 'longitude']
    df = merged_df[key_columns].copy()  # <-- Add .copy() here

    # Fill missing values
    df['average_cost_for_two'] = df['average_cost_for_two'].fillna(df['average_cost_for_two'].median())
    df['aggregate_rating'] = df['aggregate_rating'].fillna(df['aggregate_rating'].median())
    df['cuisines'] = df['cuisines'].fillna('Unknown')

    # Encode categorical features
    le_city = LabelEncoder()
    df['city_encoded'] = le_city.fit_transform(df['city'])

    le_locality = LabelEncoder()
    df['locality_encoded'] = le_locality.fit_transform(df['locality'])

    le_cuisines = LabelEncoder()
    df['cuisines_encoded'] = le_cuisines.fit_transform(df['cuisines'])

    return df, le_city, le_locality, le_cuisines

file_paths = [
    "https://s3.ap-south-1.amazonaws.com/zomato.recommedation/files.csv/file1.csv",
    "https://s3.ap-south-1.amazonaws.com/zomato.recommedation/files.csv/file2.csv",
    "https://s3.ap-south-1.amazonaws.com/zomato.recommedation/files.csv/file3.csv",
    "https://s3.ap-south-1.amazonaws.com/zomato.recommedation/files.csv/file4.csv",
    "https://s3.ap-south-1.amazonaws.com/zomato.recommedation/files.csv/file5.csv"
]
df, le_city, le_locality, le_cuisines = load_and_preprocess_data(file_paths)

# Build model
def train_model(df):
    # Features and target
    X = df[['city_encoded', 'locality_encoded', 'cuisines_encoded', 'aggregate_rating', 'votes', 'price_range']]
    y = df['average_cost_for_two']

    # Impute missing values in X
    X = X.fillna(X.median())  # Fill missing values with the median
    y = y.fillna(y.median())  # Ensure y has no missing values

    # Train-test split
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Train the model
    model = RandomForestRegressor(random_state=42)
    model.fit(X_train, y_train)

    return model, X_test, y_test

def recommend(location, cuisine, top_n=5):
    filtered = df[(df['locality'] == location) & (df['cuisines'].str.contains(cuisine, case=False))]
    recommended = filtered.sort_values(by='aggregate_rating', ascending=False).head(top_n)
    return recommended[['name', 'address', 'aggregate_rating', 'average_cost_for_two']]

# Train the model
model, X_test, y_test = train_model(df)

# WEB APPLICATION
st.title("Zomato Recommendation and Price Prediction")

st.header("Restaurant Recommendation")
location = st.selectbox("Select a location:", df['locality'].unique())
cuisine = st.text_input("Enter a cuisine (e.g., Italian):")
top_n = st.slider("Number of recommendations:", min_value=1, max_value=10, value=5)

if st.button("Get Recommendations"):
    recommendations = recommend(location, cuisine, top_n)
    st.write("Top Recommendations:")
    st.dataframe(recommendations)

st.header("Average Cost Prediction")
st.write("Provide details to predict the average cost for two people.")
selected_city = st.selectbox("Select City", df['city'].unique())
selected_locality = st.selectbox("Select Locality", df['locality'].unique())
selected_cuisine = st.selectbox("Select Cuisine", df['cuisines'].unique())
rating = st.slider("Aggregate Rating", 0.0, 5.0, step=0.1)
votes = st.number_input("Number of Votes", min_value=0, value=10)
price_range = st.slider("Price Range (1 to 5)", 1, 5, step=1)

if st.button("Predict Price"):
    # Prepare input for prediction using previously fitted encoders
    input_data = pd.DataFrame({
        'city_encoded': [le_city.transform([selected_city])[0]],
        'locality_encoded': [le_locality.transform([selected_locality])[0]],
        'cuisines_encoded': [le_cuisines.transform([selected_cuisine])[0]],
        'aggregate_rating': [rating],
        'votes': [votes],
        'price_range': [price_range]
    })
    predicted_cost = model.predict(input_data)[0]
    st.write(f"Predicted Average Cost for Two People: â‚¹{predicted_cost:.2f}")

st.header("Data Insights")
st.subheader("Distribution of Average Cost")
st.bar_chart(df['average_cost_for_two'])

st.subheader("Top 10 Cuisines")
st.bar_chart(df['cuisines'].value_counts().head(10))
